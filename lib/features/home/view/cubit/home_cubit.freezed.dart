// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'home_cubit.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$HomeState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loadingAutocomplete,
    required TResult Function(List<String> terms) autocompleteLoaded,
    required TResult Function() autocompleteError,
    required TResult Function() loadingSearch,
    required TResult Function(List<Bussiness> bussiness) searchLoaded,
    required TResult Function() searchError,
    required TResult Function(bool spinned) wheelSpinned,
    required TResult Function(List<Bussiness> bussinesses) markersUpdated,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loadingAutocomplete,
    TResult? Function(List<String> terms)? autocompleteLoaded,
    TResult? Function()? autocompleteError,
    TResult? Function()? loadingSearch,
    TResult? Function(List<Bussiness> bussiness)? searchLoaded,
    TResult? Function()? searchError,
    TResult? Function(bool spinned)? wheelSpinned,
    TResult? Function(List<Bussiness> bussinesses)? markersUpdated,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loadingAutocomplete,
    TResult Function(List<String> terms)? autocompleteLoaded,
    TResult Function()? autocompleteError,
    TResult Function()? loadingSearch,
    TResult Function(List<Bussiness> bussiness)? searchLoaded,
    TResult Function()? searchError,
    TResult Function(bool spinned)? wheelSpinned,
    TResult Function(List<Bussiness> bussinesses)? markersUpdated,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_LoadingAutocomplete value) loadingAutocomplete,
    required TResult Function(_AutocompleteLoaded value) autocompleteLoaded,
    required TResult Function(_AutocompleteError value) autocompleteError,
    required TResult Function(_LoadingSearch value) loadingSearch,
    required TResult Function(_SearchLoaded value) searchLoaded,
    required TResult Function(_SearchError value) searchError,
    required TResult Function(_WheelSpinned value) wheelSpinned,
    required TResult Function(_MarkersUpdated value) markersUpdated,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_LoadingAutocomplete value)? loadingAutocomplete,
    TResult? Function(_AutocompleteLoaded value)? autocompleteLoaded,
    TResult? Function(_AutocompleteError value)? autocompleteError,
    TResult? Function(_LoadingSearch value)? loadingSearch,
    TResult? Function(_SearchLoaded value)? searchLoaded,
    TResult? Function(_SearchError value)? searchError,
    TResult? Function(_WheelSpinned value)? wheelSpinned,
    TResult? Function(_MarkersUpdated value)? markersUpdated,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_LoadingAutocomplete value)? loadingAutocomplete,
    TResult Function(_AutocompleteLoaded value)? autocompleteLoaded,
    TResult Function(_AutocompleteError value)? autocompleteError,
    TResult Function(_LoadingSearch value)? loadingSearch,
    TResult Function(_SearchLoaded value)? searchLoaded,
    TResult Function(_SearchError value)? searchError,
    TResult Function(_WheelSpinned value)? wheelSpinned,
    TResult Function(_MarkersUpdated value)? markersUpdated,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $HomeStateCopyWith<$Res> {
  factory $HomeStateCopyWith(HomeState value, $Res Function(HomeState) then) =
      _$HomeStateCopyWithImpl<$Res, HomeState>;
}

/// @nodoc
class _$HomeStateCopyWithImpl<$Res, $Val extends HomeState>
    implements $HomeStateCopyWith<$Res> {
  _$HomeStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$InitialImplCopyWith<$Res> {
  factory _$$InitialImplCopyWith(
          _$InitialImpl value, $Res Function(_$InitialImpl) then) =
      __$$InitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InitialImplCopyWithImpl<$Res>
    extends _$HomeStateCopyWithImpl<$Res, _$InitialImpl>
    implements _$$InitialImplCopyWith<$Res> {
  __$$InitialImplCopyWithImpl(
      _$InitialImpl _value, $Res Function(_$InitialImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$InitialImpl implements _Initial {
  const _$InitialImpl();

  @override
  String toString() {
    return 'HomeState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loadingAutocomplete,
    required TResult Function(List<String> terms) autocompleteLoaded,
    required TResult Function() autocompleteError,
    required TResult Function() loadingSearch,
    required TResult Function(List<Bussiness> bussiness) searchLoaded,
    required TResult Function() searchError,
    required TResult Function(bool spinned) wheelSpinned,
    required TResult Function(List<Bussiness> bussinesses) markersUpdated,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loadingAutocomplete,
    TResult? Function(List<String> terms)? autocompleteLoaded,
    TResult? Function()? autocompleteError,
    TResult? Function()? loadingSearch,
    TResult? Function(List<Bussiness> bussiness)? searchLoaded,
    TResult? Function()? searchError,
    TResult? Function(bool spinned)? wheelSpinned,
    TResult? Function(List<Bussiness> bussinesses)? markersUpdated,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loadingAutocomplete,
    TResult Function(List<String> terms)? autocompleteLoaded,
    TResult Function()? autocompleteError,
    TResult Function()? loadingSearch,
    TResult Function(List<Bussiness> bussiness)? searchLoaded,
    TResult Function()? searchError,
    TResult Function(bool spinned)? wheelSpinned,
    TResult Function(List<Bussiness> bussinesses)? markersUpdated,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_LoadingAutocomplete value) loadingAutocomplete,
    required TResult Function(_AutocompleteLoaded value) autocompleteLoaded,
    required TResult Function(_AutocompleteError value) autocompleteError,
    required TResult Function(_LoadingSearch value) loadingSearch,
    required TResult Function(_SearchLoaded value) searchLoaded,
    required TResult Function(_SearchError value) searchError,
    required TResult Function(_WheelSpinned value) wheelSpinned,
    required TResult Function(_MarkersUpdated value) markersUpdated,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_LoadingAutocomplete value)? loadingAutocomplete,
    TResult? Function(_AutocompleteLoaded value)? autocompleteLoaded,
    TResult? Function(_AutocompleteError value)? autocompleteError,
    TResult? Function(_LoadingSearch value)? loadingSearch,
    TResult? Function(_SearchLoaded value)? searchLoaded,
    TResult? Function(_SearchError value)? searchError,
    TResult? Function(_WheelSpinned value)? wheelSpinned,
    TResult? Function(_MarkersUpdated value)? markersUpdated,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_LoadingAutocomplete value)? loadingAutocomplete,
    TResult Function(_AutocompleteLoaded value)? autocompleteLoaded,
    TResult Function(_AutocompleteError value)? autocompleteError,
    TResult Function(_LoadingSearch value)? loadingSearch,
    TResult Function(_SearchLoaded value)? searchLoaded,
    TResult Function(_SearchError value)? searchError,
    TResult Function(_WheelSpinned value)? wheelSpinned,
    TResult Function(_MarkersUpdated value)? markersUpdated,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _Initial implements HomeState {
  const factory _Initial() = _$InitialImpl;
}

/// @nodoc
abstract class _$$LoadingAutocompleteImplCopyWith<$Res> {
  factory _$$LoadingAutocompleteImplCopyWith(_$LoadingAutocompleteImpl value,
          $Res Function(_$LoadingAutocompleteImpl) then) =
      __$$LoadingAutocompleteImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadingAutocompleteImplCopyWithImpl<$Res>
    extends _$HomeStateCopyWithImpl<$Res, _$LoadingAutocompleteImpl>
    implements _$$LoadingAutocompleteImplCopyWith<$Res> {
  __$$LoadingAutocompleteImplCopyWithImpl(_$LoadingAutocompleteImpl _value,
      $Res Function(_$LoadingAutocompleteImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$LoadingAutocompleteImpl implements _LoadingAutocomplete {
  const _$LoadingAutocompleteImpl();

  @override
  String toString() {
    return 'HomeState.loadingAutocomplete()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoadingAutocompleteImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loadingAutocomplete,
    required TResult Function(List<String> terms) autocompleteLoaded,
    required TResult Function() autocompleteError,
    required TResult Function() loadingSearch,
    required TResult Function(List<Bussiness> bussiness) searchLoaded,
    required TResult Function() searchError,
    required TResult Function(bool spinned) wheelSpinned,
    required TResult Function(List<Bussiness> bussinesses) markersUpdated,
  }) {
    return loadingAutocomplete();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loadingAutocomplete,
    TResult? Function(List<String> terms)? autocompleteLoaded,
    TResult? Function()? autocompleteError,
    TResult? Function()? loadingSearch,
    TResult? Function(List<Bussiness> bussiness)? searchLoaded,
    TResult? Function()? searchError,
    TResult? Function(bool spinned)? wheelSpinned,
    TResult? Function(List<Bussiness> bussinesses)? markersUpdated,
  }) {
    return loadingAutocomplete?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loadingAutocomplete,
    TResult Function(List<String> terms)? autocompleteLoaded,
    TResult Function()? autocompleteError,
    TResult Function()? loadingSearch,
    TResult Function(List<Bussiness> bussiness)? searchLoaded,
    TResult Function()? searchError,
    TResult Function(bool spinned)? wheelSpinned,
    TResult Function(List<Bussiness> bussinesses)? markersUpdated,
    required TResult orElse(),
  }) {
    if (loadingAutocomplete != null) {
      return loadingAutocomplete();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_LoadingAutocomplete value) loadingAutocomplete,
    required TResult Function(_AutocompleteLoaded value) autocompleteLoaded,
    required TResult Function(_AutocompleteError value) autocompleteError,
    required TResult Function(_LoadingSearch value) loadingSearch,
    required TResult Function(_SearchLoaded value) searchLoaded,
    required TResult Function(_SearchError value) searchError,
    required TResult Function(_WheelSpinned value) wheelSpinned,
    required TResult Function(_MarkersUpdated value) markersUpdated,
  }) {
    return loadingAutocomplete(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_LoadingAutocomplete value)? loadingAutocomplete,
    TResult? Function(_AutocompleteLoaded value)? autocompleteLoaded,
    TResult? Function(_AutocompleteError value)? autocompleteError,
    TResult? Function(_LoadingSearch value)? loadingSearch,
    TResult? Function(_SearchLoaded value)? searchLoaded,
    TResult? Function(_SearchError value)? searchError,
    TResult? Function(_WheelSpinned value)? wheelSpinned,
    TResult? Function(_MarkersUpdated value)? markersUpdated,
  }) {
    return loadingAutocomplete?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_LoadingAutocomplete value)? loadingAutocomplete,
    TResult Function(_AutocompleteLoaded value)? autocompleteLoaded,
    TResult Function(_AutocompleteError value)? autocompleteError,
    TResult Function(_LoadingSearch value)? loadingSearch,
    TResult Function(_SearchLoaded value)? searchLoaded,
    TResult Function(_SearchError value)? searchError,
    TResult Function(_WheelSpinned value)? wheelSpinned,
    TResult Function(_MarkersUpdated value)? markersUpdated,
    required TResult orElse(),
  }) {
    if (loadingAutocomplete != null) {
      return loadingAutocomplete(this);
    }
    return orElse();
  }
}

abstract class _LoadingAutocomplete implements HomeState {
  const factory _LoadingAutocomplete() = _$LoadingAutocompleteImpl;
}

/// @nodoc
abstract class _$$AutocompleteLoadedImplCopyWith<$Res> {
  factory _$$AutocompleteLoadedImplCopyWith(_$AutocompleteLoadedImpl value,
          $Res Function(_$AutocompleteLoadedImpl) then) =
      __$$AutocompleteLoadedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<String> terms});
}

/// @nodoc
class __$$AutocompleteLoadedImplCopyWithImpl<$Res>
    extends _$HomeStateCopyWithImpl<$Res, _$AutocompleteLoadedImpl>
    implements _$$AutocompleteLoadedImplCopyWith<$Res> {
  __$$AutocompleteLoadedImplCopyWithImpl(_$AutocompleteLoadedImpl _value,
      $Res Function(_$AutocompleteLoadedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? terms = null,
  }) {
    return _then(_$AutocompleteLoadedImpl(
      null == terms
          ? _value._terms
          : terms // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc

class _$AutocompleteLoadedImpl implements _AutocompleteLoaded {
  const _$AutocompleteLoadedImpl(final List<String> terms) : _terms = terms;

  final List<String> _terms;
  @override
  List<String> get terms {
    if (_terms is EqualUnmodifiableListView) return _terms;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_terms);
  }

  @override
  String toString() {
    return 'HomeState.autocompleteLoaded(terms: $terms)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AutocompleteLoadedImpl &&
            const DeepCollectionEquality().equals(other._terms, _terms));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_terms));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AutocompleteLoadedImplCopyWith<_$AutocompleteLoadedImpl> get copyWith =>
      __$$AutocompleteLoadedImplCopyWithImpl<_$AutocompleteLoadedImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loadingAutocomplete,
    required TResult Function(List<String> terms) autocompleteLoaded,
    required TResult Function() autocompleteError,
    required TResult Function() loadingSearch,
    required TResult Function(List<Bussiness> bussiness) searchLoaded,
    required TResult Function() searchError,
    required TResult Function(bool spinned) wheelSpinned,
    required TResult Function(List<Bussiness> bussinesses) markersUpdated,
  }) {
    return autocompleteLoaded(terms);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loadingAutocomplete,
    TResult? Function(List<String> terms)? autocompleteLoaded,
    TResult? Function()? autocompleteError,
    TResult? Function()? loadingSearch,
    TResult? Function(List<Bussiness> bussiness)? searchLoaded,
    TResult? Function()? searchError,
    TResult? Function(bool spinned)? wheelSpinned,
    TResult? Function(List<Bussiness> bussinesses)? markersUpdated,
  }) {
    return autocompleteLoaded?.call(terms);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loadingAutocomplete,
    TResult Function(List<String> terms)? autocompleteLoaded,
    TResult Function()? autocompleteError,
    TResult Function()? loadingSearch,
    TResult Function(List<Bussiness> bussiness)? searchLoaded,
    TResult Function()? searchError,
    TResult Function(bool spinned)? wheelSpinned,
    TResult Function(List<Bussiness> bussinesses)? markersUpdated,
    required TResult orElse(),
  }) {
    if (autocompleteLoaded != null) {
      return autocompleteLoaded(terms);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_LoadingAutocomplete value) loadingAutocomplete,
    required TResult Function(_AutocompleteLoaded value) autocompleteLoaded,
    required TResult Function(_AutocompleteError value) autocompleteError,
    required TResult Function(_LoadingSearch value) loadingSearch,
    required TResult Function(_SearchLoaded value) searchLoaded,
    required TResult Function(_SearchError value) searchError,
    required TResult Function(_WheelSpinned value) wheelSpinned,
    required TResult Function(_MarkersUpdated value) markersUpdated,
  }) {
    return autocompleteLoaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_LoadingAutocomplete value)? loadingAutocomplete,
    TResult? Function(_AutocompleteLoaded value)? autocompleteLoaded,
    TResult? Function(_AutocompleteError value)? autocompleteError,
    TResult? Function(_LoadingSearch value)? loadingSearch,
    TResult? Function(_SearchLoaded value)? searchLoaded,
    TResult? Function(_SearchError value)? searchError,
    TResult? Function(_WheelSpinned value)? wheelSpinned,
    TResult? Function(_MarkersUpdated value)? markersUpdated,
  }) {
    return autocompleteLoaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_LoadingAutocomplete value)? loadingAutocomplete,
    TResult Function(_AutocompleteLoaded value)? autocompleteLoaded,
    TResult Function(_AutocompleteError value)? autocompleteError,
    TResult Function(_LoadingSearch value)? loadingSearch,
    TResult Function(_SearchLoaded value)? searchLoaded,
    TResult Function(_SearchError value)? searchError,
    TResult Function(_WheelSpinned value)? wheelSpinned,
    TResult Function(_MarkersUpdated value)? markersUpdated,
    required TResult orElse(),
  }) {
    if (autocompleteLoaded != null) {
      return autocompleteLoaded(this);
    }
    return orElse();
  }
}

abstract class _AutocompleteLoaded implements HomeState {
  const factory _AutocompleteLoaded(final List<String> terms) =
      _$AutocompleteLoadedImpl;

  List<String> get terms;
  @JsonKey(ignore: true)
  _$$AutocompleteLoadedImplCopyWith<_$AutocompleteLoadedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AutocompleteErrorImplCopyWith<$Res> {
  factory _$$AutocompleteErrorImplCopyWith(_$AutocompleteErrorImpl value,
          $Res Function(_$AutocompleteErrorImpl) then) =
      __$$AutocompleteErrorImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AutocompleteErrorImplCopyWithImpl<$Res>
    extends _$HomeStateCopyWithImpl<$Res, _$AutocompleteErrorImpl>
    implements _$$AutocompleteErrorImplCopyWith<$Res> {
  __$$AutocompleteErrorImplCopyWithImpl(_$AutocompleteErrorImpl _value,
      $Res Function(_$AutocompleteErrorImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$AutocompleteErrorImpl implements _AutocompleteError {
  const _$AutocompleteErrorImpl();

  @override
  String toString() {
    return 'HomeState.autocompleteError()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$AutocompleteErrorImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loadingAutocomplete,
    required TResult Function(List<String> terms) autocompleteLoaded,
    required TResult Function() autocompleteError,
    required TResult Function() loadingSearch,
    required TResult Function(List<Bussiness> bussiness) searchLoaded,
    required TResult Function() searchError,
    required TResult Function(bool spinned) wheelSpinned,
    required TResult Function(List<Bussiness> bussinesses) markersUpdated,
  }) {
    return autocompleteError();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loadingAutocomplete,
    TResult? Function(List<String> terms)? autocompleteLoaded,
    TResult? Function()? autocompleteError,
    TResult? Function()? loadingSearch,
    TResult? Function(List<Bussiness> bussiness)? searchLoaded,
    TResult? Function()? searchError,
    TResult? Function(bool spinned)? wheelSpinned,
    TResult? Function(List<Bussiness> bussinesses)? markersUpdated,
  }) {
    return autocompleteError?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loadingAutocomplete,
    TResult Function(List<String> terms)? autocompleteLoaded,
    TResult Function()? autocompleteError,
    TResult Function()? loadingSearch,
    TResult Function(List<Bussiness> bussiness)? searchLoaded,
    TResult Function()? searchError,
    TResult Function(bool spinned)? wheelSpinned,
    TResult Function(List<Bussiness> bussinesses)? markersUpdated,
    required TResult orElse(),
  }) {
    if (autocompleteError != null) {
      return autocompleteError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_LoadingAutocomplete value) loadingAutocomplete,
    required TResult Function(_AutocompleteLoaded value) autocompleteLoaded,
    required TResult Function(_AutocompleteError value) autocompleteError,
    required TResult Function(_LoadingSearch value) loadingSearch,
    required TResult Function(_SearchLoaded value) searchLoaded,
    required TResult Function(_SearchError value) searchError,
    required TResult Function(_WheelSpinned value) wheelSpinned,
    required TResult Function(_MarkersUpdated value) markersUpdated,
  }) {
    return autocompleteError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_LoadingAutocomplete value)? loadingAutocomplete,
    TResult? Function(_AutocompleteLoaded value)? autocompleteLoaded,
    TResult? Function(_AutocompleteError value)? autocompleteError,
    TResult? Function(_LoadingSearch value)? loadingSearch,
    TResult? Function(_SearchLoaded value)? searchLoaded,
    TResult? Function(_SearchError value)? searchError,
    TResult? Function(_WheelSpinned value)? wheelSpinned,
    TResult? Function(_MarkersUpdated value)? markersUpdated,
  }) {
    return autocompleteError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_LoadingAutocomplete value)? loadingAutocomplete,
    TResult Function(_AutocompleteLoaded value)? autocompleteLoaded,
    TResult Function(_AutocompleteError value)? autocompleteError,
    TResult Function(_LoadingSearch value)? loadingSearch,
    TResult Function(_SearchLoaded value)? searchLoaded,
    TResult Function(_SearchError value)? searchError,
    TResult Function(_WheelSpinned value)? wheelSpinned,
    TResult Function(_MarkersUpdated value)? markersUpdated,
    required TResult orElse(),
  }) {
    if (autocompleteError != null) {
      return autocompleteError(this);
    }
    return orElse();
  }
}

abstract class _AutocompleteError implements HomeState {
  const factory _AutocompleteError() = _$AutocompleteErrorImpl;
}

/// @nodoc
abstract class _$$LoadingSearchImplCopyWith<$Res> {
  factory _$$LoadingSearchImplCopyWith(
          _$LoadingSearchImpl value, $Res Function(_$LoadingSearchImpl) then) =
      __$$LoadingSearchImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadingSearchImplCopyWithImpl<$Res>
    extends _$HomeStateCopyWithImpl<$Res, _$LoadingSearchImpl>
    implements _$$LoadingSearchImplCopyWith<$Res> {
  __$$LoadingSearchImplCopyWithImpl(
      _$LoadingSearchImpl _value, $Res Function(_$LoadingSearchImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$LoadingSearchImpl implements _LoadingSearch {
  const _$LoadingSearchImpl();

  @override
  String toString() {
    return 'HomeState.loadingSearch()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LoadingSearchImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loadingAutocomplete,
    required TResult Function(List<String> terms) autocompleteLoaded,
    required TResult Function() autocompleteError,
    required TResult Function() loadingSearch,
    required TResult Function(List<Bussiness> bussiness) searchLoaded,
    required TResult Function() searchError,
    required TResult Function(bool spinned) wheelSpinned,
    required TResult Function(List<Bussiness> bussinesses) markersUpdated,
  }) {
    return loadingSearch();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loadingAutocomplete,
    TResult? Function(List<String> terms)? autocompleteLoaded,
    TResult? Function()? autocompleteError,
    TResult? Function()? loadingSearch,
    TResult? Function(List<Bussiness> bussiness)? searchLoaded,
    TResult? Function()? searchError,
    TResult? Function(bool spinned)? wheelSpinned,
    TResult? Function(List<Bussiness> bussinesses)? markersUpdated,
  }) {
    return loadingSearch?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loadingAutocomplete,
    TResult Function(List<String> terms)? autocompleteLoaded,
    TResult Function()? autocompleteError,
    TResult Function()? loadingSearch,
    TResult Function(List<Bussiness> bussiness)? searchLoaded,
    TResult Function()? searchError,
    TResult Function(bool spinned)? wheelSpinned,
    TResult Function(List<Bussiness> bussinesses)? markersUpdated,
    required TResult orElse(),
  }) {
    if (loadingSearch != null) {
      return loadingSearch();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_LoadingAutocomplete value) loadingAutocomplete,
    required TResult Function(_AutocompleteLoaded value) autocompleteLoaded,
    required TResult Function(_AutocompleteError value) autocompleteError,
    required TResult Function(_LoadingSearch value) loadingSearch,
    required TResult Function(_SearchLoaded value) searchLoaded,
    required TResult Function(_SearchError value) searchError,
    required TResult Function(_WheelSpinned value) wheelSpinned,
    required TResult Function(_MarkersUpdated value) markersUpdated,
  }) {
    return loadingSearch(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_LoadingAutocomplete value)? loadingAutocomplete,
    TResult? Function(_AutocompleteLoaded value)? autocompleteLoaded,
    TResult? Function(_AutocompleteError value)? autocompleteError,
    TResult? Function(_LoadingSearch value)? loadingSearch,
    TResult? Function(_SearchLoaded value)? searchLoaded,
    TResult? Function(_SearchError value)? searchError,
    TResult? Function(_WheelSpinned value)? wheelSpinned,
    TResult? Function(_MarkersUpdated value)? markersUpdated,
  }) {
    return loadingSearch?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_LoadingAutocomplete value)? loadingAutocomplete,
    TResult Function(_AutocompleteLoaded value)? autocompleteLoaded,
    TResult Function(_AutocompleteError value)? autocompleteError,
    TResult Function(_LoadingSearch value)? loadingSearch,
    TResult Function(_SearchLoaded value)? searchLoaded,
    TResult Function(_SearchError value)? searchError,
    TResult Function(_WheelSpinned value)? wheelSpinned,
    TResult Function(_MarkersUpdated value)? markersUpdated,
    required TResult orElse(),
  }) {
    if (loadingSearch != null) {
      return loadingSearch(this);
    }
    return orElse();
  }
}

abstract class _LoadingSearch implements HomeState {
  const factory _LoadingSearch() = _$LoadingSearchImpl;
}

/// @nodoc
abstract class _$$SearchLoadedImplCopyWith<$Res> {
  factory _$$SearchLoadedImplCopyWith(
          _$SearchLoadedImpl value, $Res Function(_$SearchLoadedImpl) then) =
      __$$SearchLoadedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<Bussiness> bussiness});
}

/// @nodoc
class __$$SearchLoadedImplCopyWithImpl<$Res>
    extends _$HomeStateCopyWithImpl<$Res, _$SearchLoadedImpl>
    implements _$$SearchLoadedImplCopyWith<$Res> {
  __$$SearchLoadedImplCopyWithImpl(
      _$SearchLoadedImpl _value, $Res Function(_$SearchLoadedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? bussiness = null,
  }) {
    return _then(_$SearchLoadedImpl(
      null == bussiness
          ? _value._bussiness
          : bussiness // ignore: cast_nullable_to_non_nullable
              as List<Bussiness>,
    ));
  }
}

/// @nodoc

class _$SearchLoadedImpl implements _SearchLoaded {
  const _$SearchLoadedImpl(final List<Bussiness> bussiness)
      : _bussiness = bussiness;

  final List<Bussiness> _bussiness;
  @override
  List<Bussiness> get bussiness {
    if (_bussiness is EqualUnmodifiableListView) return _bussiness;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_bussiness);
  }

  @override
  String toString() {
    return 'HomeState.searchLoaded(bussiness: $bussiness)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SearchLoadedImpl &&
            const DeepCollectionEquality()
                .equals(other._bussiness, _bussiness));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_bussiness));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SearchLoadedImplCopyWith<_$SearchLoadedImpl> get copyWith =>
      __$$SearchLoadedImplCopyWithImpl<_$SearchLoadedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loadingAutocomplete,
    required TResult Function(List<String> terms) autocompleteLoaded,
    required TResult Function() autocompleteError,
    required TResult Function() loadingSearch,
    required TResult Function(List<Bussiness> bussiness) searchLoaded,
    required TResult Function() searchError,
    required TResult Function(bool spinned) wheelSpinned,
    required TResult Function(List<Bussiness> bussinesses) markersUpdated,
  }) {
    return searchLoaded(bussiness);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loadingAutocomplete,
    TResult? Function(List<String> terms)? autocompleteLoaded,
    TResult? Function()? autocompleteError,
    TResult? Function()? loadingSearch,
    TResult? Function(List<Bussiness> bussiness)? searchLoaded,
    TResult? Function()? searchError,
    TResult? Function(bool spinned)? wheelSpinned,
    TResult? Function(List<Bussiness> bussinesses)? markersUpdated,
  }) {
    return searchLoaded?.call(bussiness);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loadingAutocomplete,
    TResult Function(List<String> terms)? autocompleteLoaded,
    TResult Function()? autocompleteError,
    TResult Function()? loadingSearch,
    TResult Function(List<Bussiness> bussiness)? searchLoaded,
    TResult Function()? searchError,
    TResult Function(bool spinned)? wheelSpinned,
    TResult Function(List<Bussiness> bussinesses)? markersUpdated,
    required TResult orElse(),
  }) {
    if (searchLoaded != null) {
      return searchLoaded(bussiness);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_LoadingAutocomplete value) loadingAutocomplete,
    required TResult Function(_AutocompleteLoaded value) autocompleteLoaded,
    required TResult Function(_AutocompleteError value) autocompleteError,
    required TResult Function(_LoadingSearch value) loadingSearch,
    required TResult Function(_SearchLoaded value) searchLoaded,
    required TResult Function(_SearchError value) searchError,
    required TResult Function(_WheelSpinned value) wheelSpinned,
    required TResult Function(_MarkersUpdated value) markersUpdated,
  }) {
    return searchLoaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_LoadingAutocomplete value)? loadingAutocomplete,
    TResult? Function(_AutocompleteLoaded value)? autocompleteLoaded,
    TResult? Function(_AutocompleteError value)? autocompleteError,
    TResult? Function(_LoadingSearch value)? loadingSearch,
    TResult? Function(_SearchLoaded value)? searchLoaded,
    TResult? Function(_SearchError value)? searchError,
    TResult? Function(_WheelSpinned value)? wheelSpinned,
    TResult? Function(_MarkersUpdated value)? markersUpdated,
  }) {
    return searchLoaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_LoadingAutocomplete value)? loadingAutocomplete,
    TResult Function(_AutocompleteLoaded value)? autocompleteLoaded,
    TResult Function(_AutocompleteError value)? autocompleteError,
    TResult Function(_LoadingSearch value)? loadingSearch,
    TResult Function(_SearchLoaded value)? searchLoaded,
    TResult Function(_SearchError value)? searchError,
    TResult Function(_WheelSpinned value)? wheelSpinned,
    TResult Function(_MarkersUpdated value)? markersUpdated,
    required TResult orElse(),
  }) {
    if (searchLoaded != null) {
      return searchLoaded(this);
    }
    return orElse();
  }
}

abstract class _SearchLoaded implements HomeState {
  const factory _SearchLoaded(final List<Bussiness> bussiness) =
      _$SearchLoadedImpl;

  List<Bussiness> get bussiness;
  @JsonKey(ignore: true)
  _$$SearchLoadedImplCopyWith<_$SearchLoadedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SearchErrorImplCopyWith<$Res> {
  factory _$$SearchErrorImplCopyWith(
          _$SearchErrorImpl value, $Res Function(_$SearchErrorImpl) then) =
      __$$SearchErrorImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SearchErrorImplCopyWithImpl<$Res>
    extends _$HomeStateCopyWithImpl<$Res, _$SearchErrorImpl>
    implements _$$SearchErrorImplCopyWith<$Res> {
  __$$SearchErrorImplCopyWithImpl(
      _$SearchErrorImpl _value, $Res Function(_$SearchErrorImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$SearchErrorImpl implements _SearchError {
  const _$SearchErrorImpl();

  @override
  String toString() {
    return 'HomeState.searchError()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$SearchErrorImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loadingAutocomplete,
    required TResult Function(List<String> terms) autocompleteLoaded,
    required TResult Function() autocompleteError,
    required TResult Function() loadingSearch,
    required TResult Function(List<Bussiness> bussiness) searchLoaded,
    required TResult Function() searchError,
    required TResult Function(bool spinned) wheelSpinned,
    required TResult Function(List<Bussiness> bussinesses) markersUpdated,
  }) {
    return searchError();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loadingAutocomplete,
    TResult? Function(List<String> terms)? autocompleteLoaded,
    TResult? Function()? autocompleteError,
    TResult? Function()? loadingSearch,
    TResult? Function(List<Bussiness> bussiness)? searchLoaded,
    TResult? Function()? searchError,
    TResult? Function(bool spinned)? wheelSpinned,
    TResult? Function(List<Bussiness> bussinesses)? markersUpdated,
  }) {
    return searchError?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loadingAutocomplete,
    TResult Function(List<String> terms)? autocompleteLoaded,
    TResult Function()? autocompleteError,
    TResult Function()? loadingSearch,
    TResult Function(List<Bussiness> bussiness)? searchLoaded,
    TResult Function()? searchError,
    TResult Function(bool spinned)? wheelSpinned,
    TResult Function(List<Bussiness> bussinesses)? markersUpdated,
    required TResult orElse(),
  }) {
    if (searchError != null) {
      return searchError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_LoadingAutocomplete value) loadingAutocomplete,
    required TResult Function(_AutocompleteLoaded value) autocompleteLoaded,
    required TResult Function(_AutocompleteError value) autocompleteError,
    required TResult Function(_LoadingSearch value) loadingSearch,
    required TResult Function(_SearchLoaded value) searchLoaded,
    required TResult Function(_SearchError value) searchError,
    required TResult Function(_WheelSpinned value) wheelSpinned,
    required TResult Function(_MarkersUpdated value) markersUpdated,
  }) {
    return searchError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_LoadingAutocomplete value)? loadingAutocomplete,
    TResult? Function(_AutocompleteLoaded value)? autocompleteLoaded,
    TResult? Function(_AutocompleteError value)? autocompleteError,
    TResult? Function(_LoadingSearch value)? loadingSearch,
    TResult? Function(_SearchLoaded value)? searchLoaded,
    TResult? Function(_SearchError value)? searchError,
    TResult? Function(_WheelSpinned value)? wheelSpinned,
    TResult? Function(_MarkersUpdated value)? markersUpdated,
  }) {
    return searchError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_LoadingAutocomplete value)? loadingAutocomplete,
    TResult Function(_AutocompleteLoaded value)? autocompleteLoaded,
    TResult Function(_AutocompleteError value)? autocompleteError,
    TResult Function(_LoadingSearch value)? loadingSearch,
    TResult Function(_SearchLoaded value)? searchLoaded,
    TResult Function(_SearchError value)? searchError,
    TResult Function(_WheelSpinned value)? wheelSpinned,
    TResult Function(_MarkersUpdated value)? markersUpdated,
    required TResult orElse(),
  }) {
    if (searchError != null) {
      return searchError(this);
    }
    return orElse();
  }
}

abstract class _SearchError implements HomeState {
  const factory _SearchError() = _$SearchErrorImpl;
}

/// @nodoc
abstract class _$$WheelSpinnedImplCopyWith<$Res> {
  factory _$$WheelSpinnedImplCopyWith(
          _$WheelSpinnedImpl value, $Res Function(_$WheelSpinnedImpl) then) =
      __$$WheelSpinnedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({bool spinned});
}

/// @nodoc
class __$$WheelSpinnedImplCopyWithImpl<$Res>
    extends _$HomeStateCopyWithImpl<$Res, _$WheelSpinnedImpl>
    implements _$$WheelSpinnedImplCopyWith<$Res> {
  __$$WheelSpinnedImplCopyWithImpl(
      _$WheelSpinnedImpl _value, $Res Function(_$WheelSpinnedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? spinned = null,
  }) {
    return _then(_$WheelSpinnedImpl(
      null == spinned
          ? _value.spinned
          : spinned // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$WheelSpinnedImpl implements _WheelSpinned {
  const _$WheelSpinnedImpl(this.spinned);

  @override
  final bool spinned;

  @override
  String toString() {
    return 'HomeState.wheelSpinned(spinned: $spinned)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WheelSpinnedImpl &&
            (identical(other.spinned, spinned) || other.spinned == spinned));
  }

  @override
  int get hashCode => Object.hash(runtimeType, spinned);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$WheelSpinnedImplCopyWith<_$WheelSpinnedImpl> get copyWith =>
      __$$WheelSpinnedImplCopyWithImpl<_$WheelSpinnedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loadingAutocomplete,
    required TResult Function(List<String> terms) autocompleteLoaded,
    required TResult Function() autocompleteError,
    required TResult Function() loadingSearch,
    required TResult Function(List<Bussiness> bussiness) searchLoaded,
    required TResult Function() searchError,
    required TResult Function(bool spinned) wheelSpinned,
    required TResult Function(List<Bussiness> bussinesses) markersUpdated,
  }) {
    return wheelSpinned(spinned);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loadingAutocomplete,
    TResult? Function(List<String> terms)? autocompleteLoaded,
    TResult? Function()? autocompleteError,
    TResult? Function()? loadingSearch,
    TResult? Function(List<Bussiness> bussiness)? searchLoaded,
    TResult? Function()? searchError,
    TResult? Function(bool spinned)? wheelSpinned,
    TResult? Function(List<Bussiness> bussinesses)? markersUpdated,
  }) {
    return wheelSpinned?.call(spinned);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loadingAutocomplete,
    TResult Function(List<String> terms)? autocompleteLoaded,
    TResult Function()? autocompleteError,
    TResult Function()? loadingSearch,
    TResult Function(List<Bussiness> bussiness)? searchLoaded,
    TResult Function()? searchError,
    TResult Function(bool spinned)? wheelSpinned,
    TResult Function(List<Bussiness> bussinesses)? markersUpdated,
    required TResult orElse(),
  }) {
    if (wheelSpinned != null) {
      return wheelSpinned(spinned);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_LoadingAutocomplete value) loadingAutocomplete,
    required TResult Function(_AutocompleteLoaded value) autocompleteLoaded,
    required TResult Function(_AutocompleteError value) autocompleteError,
    required TResult Function(_LoadingSearch value) loadingSearch,
    required TResult Function(_SearchLoaded value) searchLoaded,
    required TResult Function(_SearchError value) searchError,
    required TResult Function(_WheelSpinned value) wheelSpinned,
    required TResult Function(_MarkersUpdated value) markersUpdated,
  }) {
    return wheelSpinned(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_LoadingAutocomplete value)? loadingAutocomplete,
    TResult? Function(_AutocompleteLoaded value)? autocompleteLoaded,
    TResult? Function(_AutocompleteError value)? autocompleteError,
    TResult? Function(_LoadingSearch value)? loadingSearch,
    TResult? Function(_SearchLoaded value)? searchLoaded,
    TResult? Function(_SearchError value)? searchError,
    TResult? Function(_WheelSpinned value)? wheelSpinned,
    TResult? Function(_MarkersUpdated value)? markersUpdated,
  }) {
    return wheelSpinned?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_LoadingAutocomplete value)? loadingAutocomplete,
    TResult Function(_AutocompleteLoaded value)? autocompleteLoaded,
    TResult Function(_AutocompleteError value)? autocompleteError,
    TResult Function(_LoadingSearch value)? loadingSearch,
    TResult Function(_SearchLoaded value)? searchLoaded,
    TResult Function(_SearchError value)? searchError,
    TResult Function(_WheelSpinned value)? wheelSpinned,
    TResult Function(_MarkersUpdated value)? markersUpdated,
    required TResult orElse(),
  }) {
    if (wheelSpinned != null) {
      return wheelSpinned(this);
    }
    return orElse();
  }
}

abstract class _WheelSpinned implements HomeState {
  const factory _WheelSpinned(final bool spinned) = _$WheelSpinnedImpl;

  bool get spinned;
  @JsonKey(ignore: true)
  _$$WheelSpinnedImplCopyWith<_$WheelSpinnedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$MarkersUpdatedImplCopyWith<$Res> {
  factory _$$MarkersUpdatedImplCopyWith(_$MarkersUpdatedImpl value,
          $Res Function(_$MarkersUpdatedImpl) then) =
      __$$MarkersUpdatedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<Bussiness> bussinesses});
}

/// @nodoc
class __$$MarkersUpdatedImplCopyWithImpl<$Res>
    extends _$HomeStateCopyWithImpl<$Res, _$MarkersUpdatedImpl>
    implements _$$MarkersUpdatedImplCopyWith<$Res> {
  __$$MarkersUpdatedImplCopyWithImpl(
      _$MarkersUpdatedImpl _value, $Res Function(_$MarkersUpdatedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? bussinesses = null,
  }) {
    return _then(_$MarkersUpdatedImpl(
      null == bussinesses
          ? _value._bussinesses
          : bussinesses // ignore: cast_nullable_to_non_nullable
              as List<Bussiness>,
    ));
  }
}

/// @nodoc

class _$MarkersUpdatedImpl implements _MarkersUpdated {
  const _$MarkersUpdatedImpl(final List<Bussiness> bussinesses)
      : _bussinesses = bussinesses;

  final List<Bussiness> _bussinesses;
  @override
  List<Bussiness> get bussinesses {
    if (_bussinesses is EqualUnmodifiableListView) return _bussinesses;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_bussinesses);
  }

  @override
  String toString() {
    return 'HomeState.markersUpdated(bussinesses: $bussinesses)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MarkersUpdatedImpl &&
            const DeepCollectionEquality()
                .equals(other._bussinesses, _bussinesses));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_bussinesses));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MarkersUpdatedImplCopyWith<_$MarkersUpdatedImpl> get copyWith =>
      __$$MarkersUpdatedImplCopyWithImpl<_$MarkersUpdatedImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loadingAutocomplete,
    required TResult Function(List<String> terms) autocompleteLoaded,
    required TResult Function() autocompleteError,
    required TResult Function() loadingSearch,
    required TResult Function(List<Bussiness> bussiness) searchLoaded,
    required TResult Function() searchError,
    required TResult Function(bool spinned) wheelSpinned,
    required TResult Function(List<Bussiness> bussinesses) markersUpdated,
  }) {
    return markersUpdated(bussinesses);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loadingAutocomplete,
    TResult? Function(List<String> terms)? autocompleteLoaded,
    TResult? Function()? autocompleteError,
    TResult? Function()? loadingSearch,
    TResult? Function(List<Bussiness> bussiness)? searchLoaded,
    TResult? Function()? searchError,
    TResult? Function(bool spinned)? wheelSpinned,
    TResult? Function(List<Bussiness> bussinesses)? markersUpdated,
  }) {
    return markersUpdated?.call(bussinesses);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loadingAutocomplete,
    TResult Function(List<String> terms)? autocompleteLoaded,
    TResult Function()? autocompleteError,
    TResult Function()? loadingSearch,
    TResult Function(List<Bussiness> bussiness)? searchLoaded,
    TResult Function()? searchError,
    TResult Function(bool spinned)? wheelSpinned,
    TResult Function(List<Bussiness> bussinesses)? markersUpdated,
    required TResult orElse(),
  }) {
    if (markersUpdated != null) {
      return markersUpdated(bussinesses);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_LoadingAutocomplete value) loadingAutocomplete,
    required TResult Function(_AutocompleteLoaded value) autocompleteLoaded,
    required TResult Function(_AutocompleteError value) autocompleteError,
    required TResult Function(_LoadingSearch value) loadingSearch,
    required TResult Function(_SearchLoaded value) searchLoaded,
    required TResult Function(_SearchError value) searchError,
    required TResult Function(_WheelSpinned value) wheelSpinned,
    required TResult Function(_MarkersUpdated value) markersUpdated,
  }) {
    return markersUpdated(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_LoadingAutocomplete value)? loadingAutocomplete,
    TResult? Function(_AutocompleteLoaded value)? autocompleteLoaded,
    TResult? Function(_AutocompleteError value)? autocompleteError,
    TResult? Function(_LoadingSearch value)? loadingSearch,
    TResult? Function(_SearchLoaded value)? searchLoaded,
    TResult? Function(_SearchError value)? searchError,
    TResult? Function(_WheelSpinned value)? wheelSpinned,
    TResult? Function(_MarkersUpdated value)? markersUpdated,
  }) {
    return markersUpdated?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_LoadingAutocomplete value)? loadingAutocomplete,
    TResult Function(_AutocompleteLoaded value)? autocompleteLoaded,
    TResult Function(_AutocompleteError value)? autocompleteError,
    TResult Function(_LoadingSearch value)? loadingSearch,
    TResult Function(_SearchLoaded value)? searchLoaded,
    TResult Function(_SearchError value)? searchError,
    TResult Function(_WheelSpinned value)? wheelSpinned,
    TResult Function(_MarkersUpdated value)? markersUpdated,
    required TResult orElse(),
  }) {
    if (markersUpdated != null) {
      return markersUpdated(this);
    }
    return orElse();
  }
}

abstract class _MarkersUpdated implements HomeState {
  const factory _MarkersUpdated(final List<Bussiness> bussinesses) =
      _$MarkersUpdatedImpl;

  List<Bussiness> get bussinesses;
  @JsonKey(ignore: true)
  _$$MarkersUpdatedImplCopyWith<_$MarkersUpdatedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
